From 141c409950164847d4d16dfcaaa042039e572470 Mon Sep 17 00:00:00 2001
From: Thibaud Michaud <thibaudm@chromium.org>
Date: Tue, 9 Jan 2024 12:55:53 +0100
Subject: [PATCH 15/19] [wasm][jspi] Simplify JS frames detection

The wasm-to-js counter was introduced to detect and prevent the
accidental capture of JS frames. This was needed before, when JS frames
could be pushed alongside wasm frames in a secondary stack.

But this can be simplified now by relying on the central-stack switch:
the suspender contains JS frames if and only if it has switched to the
central stack and has not returned yet.

Rename the counter to "has_js_frames", make it a boolean, and update
this boolean when switching to/from the central stack.

R=jkummerow@chromium.org

Bug: v8:12191
Change-Id: Ic541afcefecf3776323701aec64f935988b2e38e
Reviewed-on: https://chromium-review.googlesource.com/c/v8/v8/+/5180774
Commit-Queue: Thibaud Michaud <thibaudm@chromium.org>
Reviewed-by: Jakob Kummerow <jkummerow@chromium.org>
Cr-Commit-Position: refs/heads/main@{#91761}
---
 src/builtins/wasm-to-js.tq         |  2 -
 src/builtins/wasm.tq               | 15 -------
 src/compiler/wasm-compiler.cc      | 70 +++---------------------------
 src/diagnostics/objects-printer.cc |  2 +-
 src/execution/isolate.cc           |  8 +---
 src/wasm/wasm-external-refs.cc     | 24 +++++++---
 src/wasm/wasm-objects.cc           |  2 +-
 src/wasm/wasm-objects.tq           |  2 +-
 8 files changed, 30 insertions(+), 95 deletions(-)

diff --git a/src/builtins/wasm-to-js.tq b/src/builtins/wasm-to-js.tq
index a838cb64da6..9bf94d2f220 100644
--- a/src/builtins/wasm-to-js.tq
+++ b/src/builtins/wasm-to-js.tq
@@ -65,7 +65,6 @@ transitioning macro WasmToJSWrapper(ref: WasmApiFunctionRef): WasmToJSResult {
   // 3 fixed slots, rounded up to stack alignment.
   const numFixedSlots = ((2 + alignment) / alignment) * alignment;
 
-  ModifyWasmToJSCounter(1);
   ModifyThreadInWasmFlag(0);
   // Trigger a wrapper tier-up when this function got called often enough.
   dcheck(ref.wrapper_budget > 0);
@@ -310,7 +309,6 @@ transitioning macro WasmToJSWrapper(ref: WasmApiFunctionRef): WasmToJSResult {
       numFixedSlots;
 
   ModifyThreadInWasmFlag(1);
-  ModifyWasmToJSCounter(-1);
   return WasmToJSResult{
     popCount: popCount,
     result0: *GetRefAt<intptr>(gpRegSlots, 0),
diff --git a/src/builtins/wasm.tq b/src/builtins/wasm.tq
index ea62c47b620..e2c497d1bd2 100644
--- a/src/builtins/wasm.tq
+++ b/src/builtins/wasm.tq
@@ -762,21 +762,6 @@ macro ModifyThreadInWasmFlag(newValue: int32): void {
   *threadInWasmFlagRef = newValue;
 }
 
-macro ModifyWasmToJSCounter(increment: int32): void {
-  const rootSlot = LoadPointerFromRootRegister(kActiveSuspenderOffset);
-
-  const rawSuspender = BitcastWordToTagged(rootSlot);
-  typeswitch (rawSuspender) {
-    case (activeSuspender: WasmSuspenderObject): {
-      const current = Signed(activeSuspender.wasm_to_js_counter);
-      activeSuspender.wasm_to_js_counter = Unsigned(current + increment);
-    }
-    case (Object): {
-      // Nothing to do, but the case is needed by the Torque compiler.
-    }
-  }
-}
-
 builtin WasmStringNewWtf8(
     offset: uint32, size: uint32, memory: Smi, utf8Variant: Smi): String|Null {
   const instance = LoadInstanceFromFrame();
diff --git a/src/compiler/wasm-compiler.cc b/src/compiler/wasm-compiler.cc
index 86831437c55..6845c9801fc 100644
--- a/src/compiler/wasm-compiler.cc
+++ b/src/compiler/wasm-compiler.cc
@@ -7751,15 +7751,11 @@ class WasmWrapperGraphBuilder : public WasmGraphBuilder {
     auto* call_descriptor =
         GetBuiltinCallDescriptor(Builtin::kWasmSuspend, zone_, stub_mode_);
     Node* call_target = GetTargetForBuiltinCall(Builtin::kWasmSuspend);
-    // Trap if there is any JS frame on the stack. Trap before decrementing the
-    // wasm-to-js counter, since it will already be decremented by the stack
-    // unwinder.
-    Node* counter =
-        gasm_->Load(MachineType::Int32(), suspender,
-                    wasm::ObjectAccess::ToTagged(
-                        WasmSuspenderObject::kWasmToJsCounterOffset));
-    // The counter is about to be decremented, so 1 means no JS frame.
-    Node* cond = gasm_->Word32Equal(Int32Constant(1), counter);
+    // Trap if there is any JS frame on the stack.
+    Node* has_js_frames = gasm_->Load(
+        MachineType::Int32(), suspender,
+        wasm::ObjectAccess::ToTagged(WasmSuspenderObject::kHasJsFramesOffset));
+    Node* cond = gasm_->Word32Equal(Int32Constant(0), has_js_frames);
     auto suspend = gasm_->MakeLabel();
     gasm_->GotoIf(cond, &suspend);
     // {ThrowWasmError} expects to be called from wasm code, so set the
@@ -7915,38 +7911,9 @@ class WasmWrapperGraphBuilder : public WasmGraphBuilder {
         wasm::ObjectAccess::ToTagged(WasmApiFunctionRef::kCallableOffset));
 
     Node* undefined_node = UndefinedValue();
-
     Node* call = nullptr;
-
-    Node* active_suspender;
-    if (v8_flags.experimental_wasm_stack_switching) {
-      // Increment the wasm-to-js counter before the call, and decrement it on
-      // return.
-      active_suspender = gasm_->Load(
-          MachineType::Pointer(), BuildLoadIsolateRoot(),
-          IsolateData::root_slot_offset(RootIndex::kActiveSuspender));
-      auto done = gasm_->MakeLabel();
-      Node* no_suspender =
-          gasm_->TaggedEqual(active_suspender, UndefinedValue());
-      gasm_->GotoIf(no_suspender, &done);
-      Node* counter =
-          gasm_->Load(MachineType::Int32(), active_suspender,
-                      wasm::ObjectAccess::ToTagged(
-                          WasmSuspenderObject::kWasmToJsCounterOffset));
-      counter = gasm_->Int32Add(counter, Int32Constant(1));
-      gasm_->Store(
-          StoreRepresentation(MachineRepresentation::kWord32, kNoWriteBarrier),
-          active_suspender,
-          wasm::ObjectAccess::ToTagged(
-              WasmSuspenderObject::kWasmToJsCounterOffset),
-          counter);
-      gasm_->Goto(&done);
-      gasm_->Bind(&done);
-    }
-
     // Clear the ThreadInWasm flag.
     BuildModifyThreadInWasmFlag(false);
-
     switch (kind) {
       // =======================================================================
       // === JS Functions with matching arity ==================================
@@ -8057,31 +8024,8 @@ class WasmWrapperGraphBuilder : public WasmGraphBuilder {
     // source position 0 encodes the call to the imported JS code.
     SetSourcePosition(call, 0);
 
-    if (v8_flags.experimental_wasm_stack_switching) {
-      if (suspend) {
-        call = BuildSuspend(call, Param(1), Param(0));
-      }
-      auto done = gasm_->MakeLabel();
-      Node* no_suspender =
-          gasm_->TaggedEqual(active_suspender, UndefinedValue());
-      gasm_->GotoIf(no_suspender, &done);
-      // Decrement the wasm-to-js counter.
-      active_suspender = gasm_->Load(
-          MachineType::Pointer(), BuildLoadIsolateRoot(),
-          IsolateData::root_slot_offset(RootIndex::kActiveSuspender));
-      Node* counter =
-          gasm_->Load(MachineType::Int32(), active_suspender,
-                      wasm::ObjectAccess::ToTagged(
-                          WasmSuspenderObject::kWasmToJsCounterOffset));
-      counter = gasm_->Int32Sub(counter, Int32Constant(1));
-      gasm_->Store(
-          StoreRepresentation(MachineRepresentation::kWord32, kNoWriteBarrier),
-          active_suspender,
-          wasm::ObjectAccess::ToTagged(
-              WasmSuspenderObject::kWasmToJsCounterOffset),
-          counter);
-      gasm_->Goto(&done);
-      gasm_->Bind(&done);
+    if (v8_flags.experimental_wasm_stack_switching && suspend) {
+      call = BuildSuspend(call, Param(1), Param(0));
     }
 
     // Convert the return value(s) back.
diff --git a/src/diagnostics/objects-printer.cc b/src/diagnostics/objects-printer.cc
index 2f459e09a0f..dd48c572de4 100644
--- a/src/diagnostics/objects-printer.cc
+++ b/src/diagnostics/objects-printer.cc
@@ -2329,7 +2329,7 @@ void WasmSuspenderObject::WasmSuspenderObjectPrint(std::ostream& os) {
   os << "\n - resume: " << resume();
   os << "\n - reject: " << reject();
   os << "\n - state: " << state();
-  os << "\n - wasm_to_js_counter: " << wasm_to_js_counter();
+  os << "\n - has_js_frames: " << has_js_frames();
   os << "\n";
 }
 
diff --git a/src/execution/isolate.cc b/src/execution/isolate.cc
index b3003a99efd..08f352d9f33 100644
--- a/src/execution/isolate.cc
+++ b/src/execution/isolate.cc
@@ -2163,16 +2163,10 @@ Tagged<Object> Isolate::UnwindAndFindHandler() {
       }
       case StackFrame::WASM_TO_JS:
         if (v8_flags.experimental_wasm_stack_switching) {
-          // Decrement the Wasm-to-JS counter and reset the central-stack info.
           Tagged<Object> suspender_obj = root(RootIndex::kActiveSuspender);
           if (!IsUndefined(suspender_obj)) {
             Tagged<WasmSuspenderObject> suspender =
                 WasmSuspenderObject::cast(suspender_obj);
-            int wasm_to_js_counter = suspender->wasm_to_js_counter();
-            DCHECK_LT(0, wasm_to_js_counter);
-            suspender->set_wasm_to_js_counter(wasm_to_js_counter - 1);
-
-#if V8_TARGET_ARCH_X64 || V8_TARGET_ARCH_ARM64
             // If the wasm-to-js wrapper was on a secondary stack and switched
             // to the central stack, handle the implicit switch back.
             Address central_stack_sp = *reinterpret_cast<Address*>(
@@ -2180,6 +2174,8 @@ Tagged<Object> Isolate::UnwindAndFindHandler() {
                 WasmImportWrapperFrameConstants::kCentralStackSPOffset);
             bool switched_stacks = central_stack_sp != kNullAddress;
             if (switched_stacks) {
+              DCHECK_EQ(1, suspender->has_js_frames());
+              suspender->set_has_js_frames(0);
               thread_local_top()->is_on_central_stack_flag_ = false;
               Address secondary_stack_limit = Memory<Address>(
                   frame->fp() +
diff --git a/src/wasm/wasm-external-refs.cc b/src/wasm/wasm-external-refs.cc
index 1ed01bfd56e..44aabfa4ea5 100644
--- a/src/wasm/wasm-external-refs.cc
+++ b/src/wasm/wasm-external-refs.cc
@@ -12,6 +12,7 @@
 #include "src/base/ieee754.h"
 #include "src/base/safe_conversions.h"
 #include "src/common/assert-scope.h"
+#include "src/roots/roots.h"
 #include "src/utils/memcopy.h"
 #include "src/wasm/wasm-objects-inl.h"
 
@@ -697,10 +698,17 @@ void switch_from_the_central_stack(Isolate* isolate) {
   stack_guard->SetStackLimitForStackSwitching(secondary_stack_limit);
 }
 
-intptr_t switch_to_the_central_stack_for_js(Address raw_callable,
+intptr_t switch_to_the_central_stack_for_js(Address raw_receiver,
                                             uintptr_t* stack_limit_slot) {
-  Tagged<JSReceiver> callable = JSReceiver::cast(Tagged<Object>(raw_callable));
-  Isolate* isolate = callable->GetIsolate();
+  Tagged<JSReceiver> receiver = JSReceiver::cast(Tagged<Object>(raw_receiver));
+  Isolate* isolate = receiver->GetIsolate();
+  // Set the suspender's {has_js_frames} field. The suspender contains JS
+  // frames iff it is currently on the central stack.
+  // The wasm-to-js wrapper checks this field when calling a suspending import
+  // and traps if the stack contains JS frames.
+  auto active_suspender =
+      WasmSuspenderObject::cast(isolate->root(RootIndex::kActiveSuspender));
+  active_suspender->set_has_js_frames(1);
   ThreadLocalTop* thread_local_top = isolate->thread_local_top();
   StackGuard* stack_guard = isolate->stack_guard();
   *stack_limit_slot = stack_guard->real_jslimit();
@@ -710,10 +718,14 @@ intptr_t switch_to_the_central_stack_for_js(Address raw_callable,
   return thread_local_top->central_stack_sp_;
 }
 
-void switch_from_the_central_stack_for_js(Address raw_callable,
+void switch_from_the_central_stack_for_js(Address raw_receiver,
                                           uintptr_t stack_limit) {
-  Tagged<JSReceiver> callable = JSReceiver::cast(Tagged<Object>(raw_callable));
-  Isolate* isolate = callable->GetIsolate();
+  Tagged<JSReceiver> receiver = JSReceiver::cast(Tagged<Object>(raw_receiver));
+  Isolate* isolate = receiver->GetIsolate();
+  // The stack only contains wasm frames after this JS call.
+  auto active_suspender =
+      WasmSuspenderObject::cast(isolate->root(RootIndex::kActiveSuspender));
+  active_suspender->set_has_js_frames(0);
   ThreadLocalTop* thread_local_top = isolate->thread_local_top();
   thread_local_top->is_on_central_stack_flag_ = false;
   StackGuard* stack_guard = isolate->stack_guard();
diff --git a/src/wasm/wasm-objects.cc b/src/wasm/wasm-objects.cc
index 68156df52e0..f2e3b2d814c 100644
--- a/src/wasm/wasm-objects.cc
+++ b/src/wasm/wasm-objects.cc
@@ -2026,7 +2026,7 @@ Handle<WasmSuspenderObject> WasmSuspenderObject::New(Isolate* isolate) {
       Factory::JSFunctionBuilder{isolate, reject_sfi, context}.Build();
   suspender->set_resume(*resume);
   suspender->set_reject(*reject);
-  suspender->set_wasm_to_js_counter(0);
+  suspender->set_has_js_frames(0);
   return suspender;
 }
 
diff --git a/src/wasm/wasm-objects.tq b/src/wasm/wasm-objects.tq
index 806cbb11bb4..ccc1392909b 100644
--- a/src/wasm/wasm-objects.tq
+++ b/src/wasm/wasm-objects.tq
@@ -119,7 +119,7 @@ extern class WasmSuspenderObject extends JSObject {
   // Number of Wasm-to-JS frames in this suspender's stack.
   // If the value is non-zero, this means that there are JS frames on the stack
   // and trying to suspend should trap.
-  wasm_to_js_counter: uint32;
+  has_js_frames: uint32;  // Boolean.
   @if(TAGGED_SIZE_8_BYTES) optional_padding: uint32;
   @ifnot(TAGGED_SIZE_8_BYTES) optional_padding: void;
 }
-- 
2.34.1

